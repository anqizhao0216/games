console 对象提供对浏览器控制台的接入.

Console对象可以在任何全局对象中访问.
它被浏览器定义为 Window.console，也可被简单的 console 调用.

例如：

`console.log("Failed to open the specified link")`





###打砖块游戏视频第一期总结

这个也是断断续续看了好久了，从去年大概十月份开始知道有这么一个直播。寒假的时候看了四五期，看了个热闹。这次打算按照看操作系统视频一样的看法，慢慢看。毕竟水平还不够，而且感觉可以看出很多东西。



这是一个从0到1的视频，一开始是在canvas上写了一个挡板paddle，在全局中，并在window上注册了两个事件给它，实现了按键控制挡板在页面上的移动。通过setInterval的不断调用canvas的Clear和drawImage来实现移动的效果。



效果是实现了，但是这样的代码不够好。



首先，应该以函数为基本单位。有一个入口函数main来调用其他的函数。当main返回时，整个程序结束。

然后在main中按照抽象出的对象和功能，把整个任务切分。定义好每个对象的功能。把细节写在对象内部。



所以可以将之前实现的代码抽象为两个主要部分，一个是挡板paddle，另一个是游戏背景game context。

每个对象要有自己的属性来描述自己。

paddle，image，坐标。

game，canvas。



按键之后实现挡板的移动。注册事件是在window上发生的，所以事件的绑定可以放在game上，挡板的移动属于挡板自己的行为，可以写成它自己的函数。然后通过game上的条件判断是否执行paddle的行动。

game要不断检查哪些事件被注册了，然后执行相应的回调函数。

这里有一个疑问，game的一部分函数是放在Game()中的，另一部分函数是放在了main函数中。这样做是不是可以在以后的重构中进行改进？

然后又加了一个小球，逻辑上和挡板是一样的。稍有差别。可以和挡板继承同一个



###打砖块游戏第三期实现异步加载图片

异步加载图片资源的必要性，加载一次之后，之后的每次使用就不需要加载了。节省时间。



let 和 var 的区别

```javascript
for (var i = 0 ; i < 2; i++) {
  console.log(i)
}
// 0, 1

但是如果是一个异步函数，且函数体内用到了变量i,那么取到的只是循环结束时i的最终值。因为var 声明的变量的作用域是整个函数体。每次循环调用的并没有重新声明。

如果用let声明，就可以避免这个问题。
但是let声明的变量不是全局的属性，即不可以通过window.变量名获取
let声明的变量必须在声明之后才可以使用，否则会报错
```



###打砖块游戏第四期实现拖拽

实现拖拽。

这是一个程序编写时很有用的功能。是实际开发中可能会提升开发速率的地方。是由问题出发然后解决问题。一种主动思考的表现。



### 打砖块游戏第五期 场景抽象

当游戏开始，游戏进行和游戏结束时canvas上需要画不同的东西。也就是不同的场景。

游戏逻辑：

在game完成图片载入的初始化之后，调用回调函数载入scene。

__main() 是程序入口

先加载图片资源，

```javascript
var game = GuaGame(images, 30, function(g){})
//GuaGame 是一个函数 game = 它的返回的对象

//GuaGame 定义了一个g对象并返回。
g 其实是游戏的game context，在g上定义了许多关于它的方法和属性。唯一执行的函数时加载图片，当所有图片加载完成之后，调用g.__start()，然后g.__start()调用GuaGame传进来的第三个参数，回调函数。调用的时候传入对象g。

game传入的回调函数是function(g) {
  var scene = Scene(g)
  g.runWithScene(scene)
}

回调函数先得到一个由对象g生成的scene对象，再让对象g运行这个scene。
scene对象里有paddle，block，ball
在这个scene里注册game的操作事件
```

为什么会感觉太绕了呢?